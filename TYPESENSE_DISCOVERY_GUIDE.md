# Video Discovery with Typesense

This guide explains how to use the enhanced Typesense schema for trending, popular, and related content discovery.

## Overview

The `videosV1` schema now supports:

1. **ðŸ”¥ Trending Content** - Recently popular videos
2. **â­ Popular Content** - All-time popular videos  
3. **ðŸ”— Related Content** - Similar videos based on tags, creators, and semantic similarity

## Schema Fields

### Discovery Scores

- `popularity_score` - Overall popularity (views + likes weighted)
- `trending_score` - Time-weighted popularity favoring recent engagement
- `engagement_rate` - Quality metric (likes/views ratio)

### Time-Windowed Metrics

- `views_last_24h` / `views_last_7d` - Recent view counts
- `likes_last_24h` / `likes_last_7d` - Recent like counts

### Semantic Search

- `title_embedding` - Vector embedding for semantic similarity (auto-generated by Typesense)

## Implementation Guide

### Step 1: Calculate and Update Scores

Scores should be recalculated periodically (e.g., every 15-30 minutes via cron job):

```typescript
import { updateVideoScores } from "@/server/typesense/utils/video-scoring";
import { typesenseClient } from "@/server/typesense/client";

// Example: Update scores for a video
async function refreshVideoScores(videoId: string) {
  // Fetch metrics from your database
  const metrics = await getVideoMetrics(videoId);
  
  // Calculate scores
  const scores = await updateVideoScores({
    viewCount: metrics.totalViews,
    likeCount: metrics.totalLikes,
    dislikeCount: metrics.totalDislikes,
    viewsLast24h: metrics.recentViews24h,
    viewsLast7d: metrics.recentViews7d,
    likesLast24h: metrics.recentLikes24h,
    likesLast7d: metrics.recentLikes7d,
    createdAt: metrics.createdAt,
  });
  
  // Update Typesense document
  await typesenseClient
    .collections("video_v1")
    .documents(videoId)
    .update({
      ...scores,
      view_count: metrics.totalViews,
      like_count: metrics.totalLikes,
      dislike_count: metrics.totalDislikes,
      views_last_24h: metrics.recentViews24h,
      views_last_7d: metrics.recentViews7d,
      likes_last_24h: metrics.recentLikes24h,
      likes_last_7d: metrics.recentLikes7d,
    });
}

// Run periodically for all active videos
async function refreshAllVideoScores() {
  const activeVideos = await getRecentlyActiveVideos(); // Your DB query
  
  for (const video of activeVideos) {
    await refreshVideoScores(video.id);
  }
}
```

### Step 2: Query for Trending Videos

```typescript
import { typesenseClient } from "@/server/typesense/client";
import { getTrendingVideosQuery } from "@/server/typesense/utils/video-discovery";

async function getTrendingVideos(limit = 20) {
  const query = getTrendingVideosQuery(limit);
  
  const results = await typesenseClient
    .collections("video_v1")
    .documents()
    .search(query);
  
  return results.hits?.map(hit => hit.document) || [];
}

// With filters (e.g., specific tag)
async function getTrendingVideosByTag(tagId: string, limit = 20) {
  const query = getTrendingVideosQuery(limit, `tag_ids:=${tagId}`);
  
  const results = await typesenseClient
    .collections("video_v1")
    .documents()
    .search(query);
  
  return results.hits?.map(hit => hit.document) || [];
}
```

### Step 3: Query for Popular Videos

```typescript
import { getPopularVideosQuery, getPopularVideosInTimeRangeQuery } from "@/server/typesense/utils/video-discovery";

// All-time popular
async function getPopularVideos(limit = 20) {
  const query = getPopularVideosQuery(limit);
  
  const results = await typesenseClient
    .collections("video_v1")
    .documents()
    .search(query);
  
  return results.hits?.map(hit => hit.document) || [];
}

// Popular this week
async function getPopularThisWeek(limit = 20) {
  const query = getPopularVideosInTimeRangeQuery(limit, "7d");
  
  const results = await typesenseClient
    .collections("video_v1")
    .documents()
    .search(query);
  
  return results.hits?.map(hit => hit.document) || [];
}
```

### Step 4: Query for Related Videos

#### Option A: Using Tags/Creators (Faster, simpler)

```typescript
import { getRelatedVideosByAttributesQuery } from "@/server/typesense/utils/video-discovery";

async function getRelatedVideos(videoId: string, limit = 12) {
  // First, get the reference video
  const referenceVideo = await typesenseClient
    .collections("video_v1")
    .documents(videoId)
    .retrieve();
  
  // Find videos with similar attributes
  const query = getRelatedVideosByAttributesQuery(referenceVideo, true, limit);
  
  const results = await typesenseClient
    .collections("video_v1")
    .documents()
    .search(query);
  
  return results.hits?.map(hit => hit.document) || [];
}
```

#### Option B: Using Vector Similarity (More sophisticated)

```typescript
import { getRelatedVideosByEmbeddingQuery } from "@/server/typesense/utils/video-discovery";

async function getRelatedVideosBySimilarity(videoId: string, limit = 12) {
  // Get the reference video with its embedding
  const referenceVideo = await typesenseClient
    .collections("video_v1")
    .documents(videoId)
    .retrieve();
  
  if (!referenceVideo.title_embedding) {
    // Fall back to attribute-based if no embedding
    return getRelatedVideos(videoId, limit);
  }
  
  // Use vector search
  const results = await typesenseClient
    .collections("video_v1")
    .documents()
    .search({
      q: "*",
      query_by: "title",
      filter_by: `status:approved && id:!=${videoId}`,
      vector_query: `title_embedding:(${referenceVideo.title_embedding.join(",")}, k:${limit})`,
      per_page: limit,
    });
  
  return results.hits?.map(hit => hit.document) || [];
}
```

#### Option C: Hybrid Approach (Best of both)

```typescript
async function getRelatedVideosHybrid(videoId: string, limit = 12) {
  const referenceVideo = await typesenseClient
    .collections("video_v1")
    .documents(videoId)
    .retrieve();
  
  const results: any[] = [];
  
  // Get 60% from vector similarity (if available)
  if (referenceVideo.title_embedding) {
    const vectorLimit = Math.ceil(limit * 0.6);
    const vectorResults = await getRelatedVideosBySimilarity(videoId, vectorLimit);
    results.push(...vectorResults);
  }
  
  // Fill remaining with attribute-based
  const remaining = limit - results.length;
  if (remaining > 0) {
    const attributeResults = await getRelatedVideos(videoId, remaining);
    // Filter out duplicates
    const existingIds = new Set(results.map(v => v.id));
    const uniqueResults = attributeResults.filter(v => !existingIds.has(v.id));
    results.push(...uniqueResults.slice(0, remaining));
  }
  
  return results;
}
```

### Step 5: Search with Trending Boost

```typescript
import { getSearchWithTrendingBoostQuery } from "@/server/typesense/utils/video-discovery";

async function searchVideosWithTrendingBoost(query: string, limit = 20) {
  const searchQuery = getSearchWithTrendingBoostQuery(query, limit);
  
  const results = await typesenseClient
    .collections("video_v1")
    .documents()
    .search(searchQuery);
  
  return results.hits?.map(hit => hit.document) || [];
}
```

## Cron Job Setup

Set up a periodic job to refresh scores:

```typescript
// Example using node-cron or similar
import cron from "node-cron";

// Run every 15 minutes
cron.schedule("*/15 * * * *", async () => {
  console.log("Refreshing video scores...");
  await refreshAllVideoScores();
  console.log("Video scores refreshed");
});
```

## Example Router Usage

```typescript
// src/server/api/routers/videos/discovery.ts
import { z } from "zod";
import { createTRPCRouter, publicProcedure } from "@/server/api/trpc";
import { typesenseClient } from "@/server/typesense/client";
import { 
  getTrendingVideosQuery, 
  getPopularVideosQuery,
  getRelatedVideosByAttributesQuery 
} from "@/server/typesense/utils/video-discovery";

export const discoveryRouter = createTRPCRouter({
  trending: publicProcedure
    .input(
      z.object({
        limit: z.number().min(1).max(50).default(20),
        tagId: z.string().optional(),
      })
    )
    .query(async ({ input }) => {
      const filters = input.tagId ? `tag_ids:=${input.tagId}` : undefined;
      const query = getTrendingVideosQuery(input.limit, filters);
      
      const results = await typesenseClient
        .collections("video_v1")
        .documents()
        .search(query);
      
      return results.hits?.map(hit => hit.document) || [];
    }),

  popular: publicProcedure
    .input(
      z.object({
        limit: z.number().min(1).max(50).default(20),
      })
    )
    .query(async ({ input }) => {
      const query = getPopularVideosQuery(input.limit);
      
      const results = await typesenseClient
        .collections("video_v1")
        .documents()
        .search(query);
      
      return results.hits?.map(hit => hit.document) || [];
    }),

  related: publicProcedure
    .input(
      z.object({
        videoId: z.string(),
        limit: z.number().min(1).max(50).default(12),
      })
    )
    .query(async ({ input }) => {
      const referenceVideo = await typesenseClient
        .collections("video_v1")
        .documents(input.videoId)
        .retrieve();
      
      const query = getRelatedVideosByAttributesQuery(
        referenceVideo, 
        true, 
        input.limit
      );
      
      const results = await typesenseClient
        .collections("video_v1")
        .documents()
        .search(query);
      
      return results.hits?.map(hit => hit.document) || [];
    }),
});
```

## Performance Tips

1. **Cache aggressively**: Trending/popular lists change slowly, cache for 5-15 minutes
2. **Background updates**: Update scores in background jobs, not during requests
3. **Facet queries**: Use facets to pre-compute popular tags/creators
4. **Vector search**: Only enable if you need semantic similarity, it's more expensive
5. **Time windows**: Adjust time windows (24h, 7d, 30d) based on your traffic patterns

## Advanced: Custom Trending Algorithm

You can customize the trending formula in `video-scoring.ts`:

```typescript
export function calculateTrendingScore(
  viewsLast24h: number = 0,
  viewsLast7d: number = 0,
  viewsTotal: number = 0,
  likesLast24h: number = 0,
  likesLast7d: number = 0,
  likesTotal: number = 0,
  createdAt: Date,
): number {
  // YOUR CUSTOM LOGIC HERE
  // Examples:
  // - Adjust weights (10x vs 5x for 24h vs 7d)
  // - Change time decay curve
  // - Add penalties for old videos
  // - Boost new creators
  
  return customScore;
}
```

## Next Steps

1. Set up the cron job to calculate scores
2. Integrate queries into your video routers
3. Add caching layer (Redis/in-memory)
4. Monitor query performance in Typesense dashboard
5. A/B test different trending algorithms

